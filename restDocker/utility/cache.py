"""
    File for everything that acts as buffer between the server and LTS

    The classes located here should be seen as 
"""
import sys
import os

from utility.ScanMetaData import getFile
from collections import defaultdict
from typing import Optional
from utility.lock import LockDecorator, ClassLock
from utility.helpers import lastItem
from multiprocessing import Lock

TRACKER_FOLDER = "trackers"

if not os.path.exists(TRACKER_FOLDER):
    os.makedirs(TRACKER_FOLDER)

CACHE_FOLDER = "cache"

if not os.path.exists(CACHE_FOLDER):
    os.makedirs(CACHE_FOLDER)

mutexCache = Lock()

"""
    Holds the results in files
"""
class ResultTracker(object):
    def __init__(self, path="counters.txt", mapping=None):
        self._mapping = mapping
        
        self._lock = Lock()

        self._counts = defaultdict(lambda: 0)

        self._path = f"{TRACKER_FOLDER}/{path}"
        if os.path.exists(self._path):
            self.load_()
        else:
            self.save_()

    def getResults(self):
        results = []
        for key, value in self._counts.items():
            #print(key, value, type(key))
            if(self._mapping):
                name = self._mapping[key]
            else:
                name = key
            results.append({'name': name,
                            'count': value})
            
        return results 
    
    @ClassLock
    def incr(self, key: str) -> None:
        
        self._counts[key] += 1
        
    @ClassLock
    def load_(self) -> None:
        with open(self._path, 'r') as f:
            for line in f:
                key, value = line.split('|')
                self._counts[str(key)] = int(value)

    @ClassLock
    def save_(self) -> None:
        with open("{}".format(self._path), 'w') as f:
            for (key, value), isLast in lastItem(self._counts.items()):
                if isLast:
                    f.write(f"{key}|{value}")
                else:
                    f.write(f"{key}|{value}\n")
                
    def __enter__(self):
        pass

    def __exit__(self, exc_type, exc_value, exc_tb):
        self.save_()



"""
    A simple cache for holding files

    At this point I'm trying to not have to use a more performant framework,

    so this would sit between redis and flask. since the overhead seems to be
    getting the whole data set from redis after it's finished loading


    if this gets to slow, I'll try faster json parsing or cythong or something...

    This way I can choose to save things to redis async etc if needed
"""
class Cache(object):
    def __init__(self):
        self.store_ = defaultdict(lambda: bytearray())

    @LockDecorator(mutexCache)
    def __delitem__(self, key):
        del self.store_[key]

    
    @LockDecorator(mutexCache)
    def __getitem__ (self, key) -> bytearray:
        return self.store_[key]
    

    @LockDecorator(mutexCache)
    def extend(self, key, toAdd : bytearray):
        self.store_[key].extend(toAdd)

    def exists(self, key):
        return key in self.store_
    
    def getsize(self, key):
        return sys.getsizeof(self.store_[key])
    
    @LockDecorator(mutexCache)
    def writeToFile(self, key) -> str:
        filename = self.getPath_(key)
        with open(filename, 'wb') as file:
            file.write(self.store_[key])
        
        return filename

    def getColdCopyPath(self, key) -> Optional[str]:
        filename = self.getPath_(key)
        if os.path.exists(filename):
            return filename
        return None;

    def getPath_(self, key)-> str:
        return f"{CACHE_FOLDER}/{getFile(key)}.saved"
