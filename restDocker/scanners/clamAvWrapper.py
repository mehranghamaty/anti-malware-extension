from utility.cache import ResultTracker
from scanners.scanner import Scanner

import clamd
from io import BytesIO
from flask import render_template, Blueprint

class ClamAvWrapper(Scanner):
    def __new__(cls):
        if not hasattr(cls, 'instance'):
            cls.instance = super(ClamAvWrapper, cls).__new__(cls)
        return cls.instance
    
    def __init__(self) -> None:
        try:
            self._clam = clamd.ClamdUnixSocket()
            self._avaliable = self._clam.ping() == 'PONG'
        except (FileNotFoundError, clamd.ConnectionError) as error:
            self._avaliable = False

        self._resultsTracker = ResultTracker(f"{self.__class__.__name__}.txt")
        self._bluePrint = Blueprint(
            self.__class__.__name__,
            self.__class__.__name__,
            template_folder="templates")
        self._bluePrint.add_url_rule('/dashboard', 'dashboard', self.dashboard, methods = ['GET'])

    def avaliable(self) -> bool:
        return self._avaliable

    def scan(self, data, metadata=None) -> dict:
        scanner_results = {"method" : "ClamAv"}

        if not self._avaliable:
            scanner_results["results"] = "no_scan"
            scanner_results["reason"] = "ClamAv isn't running"


        try:
            pred = self._clam.instream(BytesIO(data))
        except ConnectionResetError:
            scanner_results["results"] = "no_scan"
            scanner_results["reason"] = "File too large"
            return scanner_results
        except clamd.ConnectionError:
            scanner_results["results"] = "no_scan"
            scanner_results["reason"] = "ClamAv isn't running"
            return scanner_results


        (safe, reason) = pred["stream"]
        if safe == 'OK':
            scanner_results["results"] = "clean"
        else:
            scanner_results["results"] = "possibly_malicious"
            scanner_results["reason"] = reason
        return scanner_results
    
    def getBluePrint(self):
        return self._bluePrint
    
    def dashboard(self):
        return render_template('dashboard.html', 
                               name=self.__class__.__name__, 
                               responses=self._resultsTracker.getResults())