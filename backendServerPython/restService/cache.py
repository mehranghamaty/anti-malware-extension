"""
    File for everything that acts as buffer between the server and LTS
"""
import sys
from collections import defaultdict
from typing import Optional
import os
from multiprocessing import Lock

mutex = Lock()

DOWNLOAD_FOLDER = "tmp"

if not os.path.exists(DOWNLOAD_FOLDER):
    os.makedirs(DOWNLOAD_FOLDER)


"""
    A class for getting the results from redis, 
    may want to move the connector into the class itself.
"""
class ResultTracker:
    def __init__(self, path="counters.txt"):
        self.mapping_ = {
            -1 : "NoScan",
            0 : "Good",
            1 : "Adware",
            2 : "Trojan",
            3 : "Trojan",
            4 : "Installer",
            5 : "Backdoor",
            6 : "Crypto",
            7 : "Backdoor",
            8 : "Downloader",
            9 : "Heuristic",
        }

        self.counts_ = { i : 0 for i in range(-1,10)}
        self.path_ = path

    def getResults(self):
        results = []
        for key, value in self.counts_.items():
            results.append({'name': self.mapping_[key],
                            'count': value})
        return results 
    
    def incr(self, pred):
        mutex.acquire()
        try:
            self.count_[pred] += 1
        finally:
            mutex.release()

    def __del__(self):
        with open(self.path_, 'w') as f:
            for _, value in self.counts_.items():
                f.write(value)


"""
    A simple cache for holding files

    At this point I'm trying to not have to use a more performant framework,

    so this would sit between redis and flask. since the overhead seems to be
    getting the whole data set from redis after it's finished loading


    if this gets to slow, I'll try faster json parsing or cythong or something...

    This way I can choose to save things to redis async etc if needed
"""
class Cache:
    def __init__(self):
        self.store_ = defaultdict(lambda: bytearray())

    def __delitem__(self, key):
        del self.store_[key]

    def __getitem__ (self, key) -> bytearray:
        #print(self.store_.keys())
        return self.store_[key]
    
    """
        Would it be possible to keey a statically
        allocated array?

        Do I have to define my own binary array type?
    def __setitem__(self, key, newvalue):
        self.store_[key] = newvalue;
    """

    def extend(self, key, toAdd : bytearray):
        self.store_[key].extend(toAdd)

    def exists(self, key):
        return key in self.store_
    
    def getsize(self, key):
        return sys.getsizeof(self.store_[key])
    
    def writeToFile(self, key) -> str:
        filename = "{}/{}.saved".format(DOWNLOAD_FOLDER, key)
        if not os.path.exists(filename):
            with open(filename, 'wb') as file:
                file.write(self.store_[key])
        return filename

    def getColdCopyPath(self, key) -> Optional[str]:
        filename = "{}.saved".format(key)
        if os.path.exists(filename):
            return filename
        return None;