"""
    File for everything that acts as buffer between the server and LTS
"""
import sys
import os
import uuid

from utility.helpers import getFile
from collections import defaultdict
from typing import Optional
from utility.lock import LockDecorator
from multiprocessing import Lock

DOWNLOAD_FOLDER = "tmp"

if not os.path.exists(DOWNLOAD_FOLDER):
    os.makedirs(DOWNLOAD_FOLDER)


mutexRT = Lock()
mutexCache = Lock()

"""
    Holds the results in files
"""
class ResultTracker:
    def __init__(self, path="counters.txt"):
        self.mapping_ = {
            -1 : "NoScan",
            0 : "Good",
            1 : "Adware",
            2 : "Trojan",
            3 : "Trojan",
            4 : "Installer",
            5 : "Backdoor",
            6 : "Crypto",
            7 : "Backdoor",
            8 : "Downloader",
            9 : "Heuristic",
        }

        self.counts_ = { i : 0 for i in range(-1,10)}

        self.path_ = path
        if os.path.exists(self.path_):
            self.load_()
        else:
            self.save_()

    def getResults(self):
        results = []
        for key, value in self.counts_.items():
            results.append({'name': self.mapping_[key],
                            'count': value})
        return results 
    
    @LockDecorator(mutexRT)
    def incr(self, pred):
        self.counts_[pred] += 1
        
    def __del__(self):
        self.save_()

    @LockDecorator(mutexRT)
    def load_(self):
        with open(self.path_, 'r') as f:
            for line in f.readline():
                key, value = line.split('|')
                self.counts_[key] = value


    @LockDecorator(mutexRT)
    def save_(self):
        with open("{}/{}".format(DOWNLOAD_FOLDER, self.path_), 'w') as f:
            for key, value in self.counts_.items():
                f.write("{} | {}\n".format(key, value))


"""
    A simple cache for holding files

    At this point I'm trying to not have to use a more performant framework,

    so this would sit between redis and flask. since the overhead seems to be
    getting the whole data set from redis after it's finished loading


    if this gets to slow, I'll try faster json parsing or cythong or something...

    This way I can choose to save things to redis async etc if needed
"""
class Cache:
    def __init__(self):
        self.store_ = defaultdict(lambda: bytearray())


    @LockDecorator(mutexCache)
    def __delitem__(self, key):
        del self.store_[key]

    
    @LockDecorator(mutexCache)
    def __getitem__ (self, key) -> bytearray:
        return self.store_[key]
    

    @LockDecorator(mutexCache)
    def extend(self, key, toAdd : bytearray):
        self.store_[key].extend(toAdd)

    def exists(self, key):
        return key in self.store_
    
    def getsize(self, key):
        return sys.getsizeof(self.store_[key])
    
    @LockDecorator(mutexCache)
    def writeToFile(self, key) -> str:
        filename = self.getPath_(key)
        with open(filename, 'wb') as file:
            file.write(self.store_[key])
        
        return filename

    def getColdCopyPath(self, key) -> Optional[str]:
        filename = self.getPath_(key)
        if os.path.exists(filename):
            return filename
        return None;

    def getPath_(self, key)-> str:
        return "{}/{}.saved".format(DOWNLOAD_FOLDER, getFile(key))
