// Always Pick a variant which throws on transparent ciphertexts unless you
// have a specific reason to allow the use of transparent ciphertexts.
import SEAL from 'node-seal';
import { Buffer } from 'buffer';

class SEALWrapper {
  constructor() {
    this.initialized = false;
  }

  /**
   * @private
   */
  async initialize_() {
    this.seal = await SEAL();
    this.schemeType = this.seal.SchemeType.bfv;
    this.securityLevel = this.seal.SecurityLevel.tc128;
    this.polyModulusDegree = 4096;
    this.bitSizes = [36, 36, 37];
    this.bitSize = 20;
    this.parms = this.seal.EncryptionParameters(this.schemeType);
    // Set the PolyModulusDegree
    this.parms.setPolyModulusDegree(this.polyModulusDegree);
  
    // Create a suitable set of CoeffModulus primes
    this.parms.setCoeffModulus(
      this.seal.CoeffModulus.Create(this.polyModulusDegree, Int32Array.from(this.bitSizes))
    );
  
    // Set the PlainModulus to a prime of bitSize 20.
    this.parms.setPlainModulus(
      this.seal.PlainModulus.Batching(this.polyModulusDegree, this.bitSize)
    );
    this.context = this.seal.Context(
      this.parms, // Encryption Parameters
      true, // ExpandModChain
      this.securityLevel // Enforce a security level
    );
  
    if (!this.context.parametersSet()) {
      throw new Error(
        'Could not set the parameters in the given context. Please try different encryption parameters.'
      );
    }
    this.encoder = this.seal.BatchEncoder(this.context);
    this.keyGenerator = this.seal.KeyGenerator(this.context);
    this.publicKey = this.keyGenerator.createPublicKey();
    this.secretKey = this.keyGenerator.secretKey();
    this.encryptor = this.seal.Encryptor(this.context, this.publicKey);
    this.decryptor = this.seal.Decryptor(this.context, this.secretKey);
    this.evaluator = this.seal.Evaluator(this.context);
    this.initialized = true;
  }

  /**
   * @param {ArrayBuffer} toEncrypt
   */
  async encrypt(toEncrypt) {
    if(!this.initialized) { await this.initialize_(); }
    const array = Int32Array.from({ length: this.encoder.slotCount }).fill(0);
    const temp = new Uint8Array(toEncrypt);
    for(let i = 0; i < temp.length; ++i) {
      array[i] = temp[i];
    }
    array[temp.length] = '\0';
    // Encode the Array
    const plainText = this.seal.PlainText();
    const cipherText = this.seal.CipherText();
    this.encoder.encode(array, plainText);
    this.encryptor.encrypt(plainText, cipherText);
    return cipherText;
  }

  
  /**
   * @param {String} toDecrypt
   */
  async decrypt(toDecrypt) {
    if(!this.initialized) { await this.initialize_(); }

    let responseCipher = this.seal.CipherText();
    responseCipher.load(this.context, toDecrypt);

    const plainResult = this.seal.PlainText();
    this.decryptor.decrypt(responseCipher, plainResult);
    const decoded = this.encoder.decode(plainResult, true);
    let res = Buffer.from(decoded).toString().trim();
    return res;
  }
}

export {SEALWrapper};