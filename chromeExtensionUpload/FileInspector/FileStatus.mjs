/**
 * @fileoverview An enum class for the status of a file.
 */


export class ScannerResults {
    static Clean = new ScannerResults("clean");
    static PossiblyMalicious = new ScannerResults("possibly_malicious");
    static NoScan = new ScannerResults("no_scan");

    constructor(name) {
        this.name = name;
    }

    /**
     * @param {ScannerResults} toCompare
     * @return {boolean}
     */
    equals(toCompare) {
        return this.name === toCompare.name;
    }

    /**
     * @returns {string}
     */
    toString() {
        return this.name;
    }
}

export class ScannerMethod {
    static None = new ScannerMethod("None");
    static ClamAv = new ScannerMethod("ClamAv");
    static InHouse = new ScannerMethod("InHouse");
    static OnClient = new ScannerMethod("OnClient");
    static OnServer = new ScannerMethod("OnServer");
    
    constructor(name) {
        this.name = name;
    }

    /**
     * @param {ScannerMethod} toCompare
     * @return {boolean}
     */
    equals(toCompare) {
        return this.name === toCompare.name;
    }

    /**
     * @returns {string}
     */
    toString() {
        return this.name;
    }
}

export class FileStatus {
    static CleanOnDevice = new FileStatus(ScannerResults.Clean, ScannerMethod.OnClient, "mime-type match");
    static MimeMismatch = new FileStatus(ScannerResults.PossiblyMalicious, ScannerMethod.OnClient, "mime-type mismatch");
    static FailedToFetch = new FileStatus(ScannerResults.NoScan, ScannerMethod.OnServer, "Failed to fetch");
    static Unreachable = new FileStatus(ScannerResults.NoScan, ScannerMethod.None, "Shouldn't be here");

    /**
     * 
     * @param {ScannerResults} results 
     * @param {ScannerMethod} method 
     * @param {string} reason 
     */
    constructor(results, method, reason) {
        this.result = results;
        this.method = method;
        this.reason = reason;
    }

    /**
     * @param {FileStatus} toCompare
     * @return {boolean}
     */
    equals(toCompare) {
        return this.result.equals(toCompare.result) && this.method.equals(toCompare.method) && this.reason === toCompare.reason;
    }

    /**
     * @returns {string}
     */
    toString() {
        return this.result.toString() + ", from " + this.method.toString() + " due to " + this.reason;
    }
}