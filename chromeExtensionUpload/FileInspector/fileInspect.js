/**
 * @fileoverview a set of helper functions for inspecting files
 * 
 * At some point this should turn into a wrapper class for the File
 * class to provide additional functionality.
 */
import { FileStatus } from "./fileStatus";
import { requestScanFile } from "./restClient";

/**
 * @param {File} file
 * @return {FileStatus}
 */
async function inspectFile(file) {
    let fileStatus = await checkMimeMatches(file);
    //External requests will be saved for later. 
    if(fileStatus.equals(FileStatus.ClientReject)) {
        return fileStatus;
    }

    fileStatus = await externalRequest(file);
    return fileStatus;
} 

/**
 * @param {File} file
 * @return {FileStatus}
 */
async function externalRequest(file) {
    let response = await requestScanFile(file);
    return new FileStatus(response['status']);
}

/**
 * @param {File} file
 * @return {FileStatus}
 */
async function checkMimeMatches(file) {
    if( file.type != await getMimeFromSignature(file)) {
        return FileStatus.ClientReject;
    }
    return FileStatus.Clean;
}

/**
 * @param {File} file
 * @return {string} mimeType (defaults to what file reports)
 */
async function getMimeFromSignature(file) {
    const fileData = (new Uint8Array(await file.arrayBuffer())).subarray(0, 4);
    let bytes = [];
    fileData.forEach((byte) => bytes.push(byte.toString(16)));
    const signature = bytes.join('').toUpperCase();
    switch (signature) {
        case '89504E47':
                return 'image/png';
            case '47494638':
                return 'image/gif';
            case '25504446':
                return 'application/pdf';
            case 'FFD8FFDB':
            case 'FFD8FFE0':
            case 'FFD8FFE1':
                return 'image/jpeg';
            case '504B0304':
                return 'application/zip';
            default:
                return file.type;
    }
}

export { inspectFile };